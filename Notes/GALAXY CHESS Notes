GALAXY CHESS Notes

AW gameplay examples.
32:40, 34:40 https://www.youtube.com/watch?v=9tp36xTaZak&ab_channel=justonegamr


Names:

Ulant
Leetus
Apis
Flos
Floreo
Floris
Cagion
Cagions
Morbus
Pertinax
Pertanix
Tanix
Virix


Ertian
Ertians
Erterian
Ertrian


Archia
Vetus
Evetus
Avetus
Deuvetus
Novetus
Advena
Provectus
Proveuts
Deuvect
Provect
Sentus


    /*
    edorum = eaters. e dorum = out of the house. idorum = of the people
    e solis, a sole = from the sun
    etulus = ate
    avarus = greedy, evarus = evasive
    earthus = earthy
    erthus = shock
    herthus = garden
    */


FIRST RUN USER TEST

Bug #1: 700 resources for player2 on T1.
fixed Bug #2: menu not showing when maximized. Likely sprite not recording a click.
fixed BUG #3: Can't consistently click on production structures

Bug #4: Capturing infantry cannot unselect
Bug #5: Undo unit movement makes it unselectable    

TO DO, DON'T FORGET:
Turn on Email Auth for Supabase
Debug tilemap exportBytesToFile and importFileToBytes. I modified the serialization so I need to confirm it's not broken. For later.



ART NOTES:
red 1: 223,32,32,1
red 2: 149,21,21,1
red 3: 112,16,16,1

Light Grey:     137,137,137,1   #898989
Med Grey:       69,69,69,1      #454545
Dark Grey:      46,46,46,1      #2e2e2e

Light Colour:   255,255,255,1   #ffffff
Med Colour:     157,157,157,1   #9d9d9d
Dark Colour:    115,115,115,1   #737373


massimogordillo@hotmail.com


PROMPTS:
I'm building a 2D asynchronous Unity strategy game with Supabase as my backend service. I'm currently able to send map data to the db and want to be able to retrieve that data via http request. I have a maps table and want to receive width, height and grid_data columns. Write me a serverside .js function which will receive this request and send back this data.


Ok I think it's best we just start fresh. Let me explain my project and what I'm hoping to accomplish.

I'm building a 2D turn-based Unity game. My MVP is very simple. I want two players to be playing on one map, taking turns moving their game pieces. Imagine it's like a correspondence chess game where one player moves all their pieces, creates more, and then passes the turn to player 2 who does the same.

The MVP implementation is very light. Player 1 will send the moves they performed on their turn, and a hash of the gamestate at the end of their turn to the server. The server will validate those game moves are legal and that the end state matches the hash it also generates, and upon confirming both of those checks only then will pass the information to Player 2. The game actions performed by player 1 will be replayed visually for player 2 and then player 2 can then begin their turn from the new gamestate. There are some nuances here, primarily that there needs to be random number seed management so ther server can confirm the gamestate after receving it from a player (there is a chance/luck component).

We agreed to use Supabase as our backend service. Note that there is no concurrency required, the two user clients do not need to be connected, only pushes to the server and either a polling or push system to send the new gamestate information to the other player.

Some details for the db setup:

a single game can contain 100s of moves so it's best to make a turn_moves table which collects all the moves in a given turn.
the game will have many maps, different grid setups upon which to intialize and play the game. On the front end I've designed each map to be converted into a serialized list of bytes (using messagepack).
While I dont need this for the MVP imlementation, in the future I will want new users be able to create a profile, and create a game for another user to join. This requires account creation, forgot password, key management, login, logout, etc.
Please let me know if you need any additional information before setup.

Let's expand our db implementation:

A players table, users. Two players are paired in a match.

A matches table will contain a list of matches between two players. It will contain:
- matchID
- the player Ids
- the map name and id (from the maps table)
- who's turn it currently is
- the current gamestate (jsonb format, a list of game pieces)
- whether the match is completed or not
- a 2D array called unitGrid
- a 2D array called structureGrid
- a 2D array called terrainGrid
- creation time
- match end time (populated when match is complete)
- winner (populated when match is complete)

The three 2D array items need to be readable and writable serverside for computation and validation. Only the player who's turn it is should be able to send data to the server regarding this game. 

A matchMoves table which contains the following items:
- movesListId
- the matchID the moves are being implemented in
- the player that sent those moves
- A Jsonb list of game actions. This should be parsable by the serverside for move validation
- the time those moves were received by the server
- an isValid flag, to be set by validation service

Please provide me which any suggestions you feel I might be missing.




Ok great. I have a structural question I'd like to ask you. The game takes place on a 2D grid. Effectively, the game engine runs off of 3x 2D arrays. 
The first array is the grid_data, this is the map terrain which effects unit movement, damage multipliers etc. 
The second array is the unit_grid, this is where each unit is recorded, only one unit can be at any one index at any time. A given unit has a list of characteristics, unit type, health, ownership, etc.
The third array is the structure_grid, which is where capturable structures exist. A unit can be on top of a structure.
Whenever a player sends a list of game actions to the server, the server needs to be able to effectively recreate the gamestate from the three arrays. The server needs to be able to verify the game actions provided by the client were legal and that the final gamestate matches a hash provided by the client. 

Notably I understand there are db/json structures which allow SQL commands to reference items in arrays held in a table. Presumably I want to leverage these so that I don't have to hold/recreate all 3 arrays in some sort of temporary memory. 

Can you provide some guidance on how to apply this in our server structure?



Ok let's step back a second here. I'm using Unity to send the grid_data via http to the server for it to be held in the maps table in the grid_data column. Notable, on the Unity side the grid_data array is an array of bytes. I'm converting that array of bytes to a base64string so I can send it via http. 

What is the best way to covert this data on the Unity side so it can be sent via http to an api endpoint? Then, server side, how would I receive this information, process it into the proper data format, and save it to the db for reference with PostgreSQL's JSONB array funcionality?

Client side I'm currently creating a List of gamePieceInfo, a list of all the units and structures on the grid, and then sending that over http. This is in an attempt to not send 2x very sparse arrays via http. Does it make sense more sense to handle the data this way? Then server-side the data has to be deconstructed and items placed into the arrays in the tables. Alternatively I can just send the sparse arrays over with the unit data in their respective cells in the array. Thoughts?


OK NEW DATABASE STRUCTURE. I'm going to create a table which tracks all game pieces across all games and uses partitioning to make it managable. Create a match_piece_list table which partitions on match_id. you should also be able to quickly separate between piece_type for a given match_id. 
Columns should be match_id, piece_type (bool, 1 for unit, 0 for structure), x_loc, y_loc, type_num (int), player_controller (int), health_val (int).

In this way, instead of querying the jsonb arrays in the matches table, I can directly query a partition in the match_piece_list, and I can quickly modify individual rows to move a unit, destroy it, etc.

Ok let's rebuild the map grid data with the same idea. Make a partitioned maps_tiles table with columns x_loc, y_loc, tile_type (int). This data was previously held in the grid_data column in the maps table.

Let's also create a partitioned map_init_pieces table which records the initial piece data for a given map. Previously it was a list in maps called init_piece_data. The columns should be the same as the match_piece_list table but instead of having a match_id it has a map_id.


ok great. Let's modify the saveMap function in the MapService function to drop this data in the appropriate tables. Via JSON you'll receive an array of ints to put into the 